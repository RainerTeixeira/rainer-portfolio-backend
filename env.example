# ═══════════════════════════════════════════════════════════════════════════
# CONFIGURAÇÃO DO AMBIENTE
# ═══════════════════════════════════════════════════════════════════════════

# Ambiente de execução
NODE_ENV=development
PORT=4000
HOST=0.0.0.0
LOG_LEVEL=info

# ═══════════════════════════════════════════════════════════════════════════
# DATABASE CONFIGURATION - Arquitetura Híbrida
# ═══════════════════════════════════════════════════════════════════════════

# Provider de banco de dados
# • PRISMA: MongoDB via Prisma ORM (RECOMENDADO para desenvolvimento)
#   - Desenvolvimento rápido e produtivo
#   - Prisma Studio (GUI visual)
#   - Type-safe queries
#   - Ideal para: dev, test, staging
#
# • DYNAMODB: AWS DynamoDB (produção serverless)
#   - Serverless, escalável
#   - Pay-per-request
#   - Alta disponibilidade
#   - Ideal para: produção AWS Lambda
DATABASE_PROVIDER=PRISMA

# MongoDB Connection String (obrigatório quando DATABASE_PROVIDER=PRISMA)
# IMPORTANTE: Prisma 6+ requer MongoDB em modo Replica Set
# 
# Desenvolvimento Local (Docker):
#   docker run -d --name mongodb -p 27017:27017 mongo:7 --replSet rs0
#   docker exec mongodb mongosh --eval "rs.initiate()"
#
# Produção (MongoDB Atlas):
#   mongodb+srv://username:password@cluster.mongodb.net/blog
DATABASE_URL="mongodb://localhost:27017/blog?replicaSet=rs0&directConnection=true"

# ═══════════════════════════════════════════════════════════════════════════
# AWS CONFIGURATION
# ═══════════════════════════════════════════════════════════════════════════

# Região AWS
AWS_REGION=us-east-1

# Credenciais AWS (opcional - não necessário em Lambda)
AWS_ACCESS_KEY_ID=fakeAccessKeyId
AWS_SECRET_ACCESS_KEY=fakeSecretAccessKey

# DynamoDB Local Endpoint (apenas para desenvolvimento/testes)
# Use para testar com DynamoDB Local antes do deploy
# Em produção AWS Lambda, remover ou comentar esta linha
# Docker: docker-compose up -d dynamodb-local
DYNAMODB_ENDPOINT=http://localhost:8000

# Prefixo das tabelas DynamoDB (usado quando DATABASE_PROVIDER=DYNAMODB)
# Permite múltiplos ambientes na mesma conta AWS
# Exemplos: 'blog' (dev), 'blog-staging', 'blog-prod'
# Tabelas criadas: {prefix}-users, {prefix}-posts, {prefix}-categories,
#                  {prefix}-comments, {prefix}-likes, {prefix}-bookmarks,
#                  {prefix}-notifications
DYNAMODB_TABLE_PREFIX=blog

# ═══════════════════════════════════════════════════════════════════════════
# AWS COGNITO CONFIGURATION
# ═══════════════════════════════════════════════════════════════════════════

# ID do User Pool do Cognito
# Exemplo: us-east-1_XXXXXXXXX
COGNITO_USER_POOL_ID=us-east-1_XXXXXXXXX

# ID do App Client no Cognito
COGNITO_CLIENT_ID=xxxxxxxxxxxxxxxxxxxxxxxxxx

# Secret do App Client (opcional - apenas se configurado no Cognito)
# COGNITO_CLIENT_SECRET=xxxxxxxxxxxxxxxxxxxxxxxxxx

# Região do Cognito (geralmente igual a AWS_REGION)
COGNITO_REGION=us-east-1

# Issuer do JWT (URL do User Pool)
# Formato: https://cognito-idp.{region}.amazonaws.com/{userPoolId}
COGNITO_ISSUER=https://cognito-idp.us-east-1.amazonaws.com/us-east-1_XXXXXXXXX

# Secret para JWT (usado como fallback)
JWT_SECRET=your-secret-key-change-in-production

